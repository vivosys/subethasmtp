<html>
<head>
 <style type="text/css">
/* <![CDATA[ */ 
@import "http://www.tigris.org/branding/css/tigris.css"; 
@import "http://www.tigris.org/branding/css/inst.css"; 
/*  ]]> */
 </style>
  <link rel="stylesheet" type="text/css" href="http://www.tigris.org/branding/css/print.css" media="print" />
<script src="http://www.tigris.org/branding/scripts/tigris.js" type="text/javascript">
</script>
 <title>SubEtha SMTP</title>
</head>
<body>
	<p>
		<a href="http://en.wikipedia.org/wiki/Sub-Etha">SubEtha</a> SMTP is
		a Java library which provides a receptive SMTP server component.
		By plugging this component into your Java application, you can
		easily receive SMTP mail using a simple abstract Java interface.
	</p>
	
	<p>
		This component can be used in almost any kind of email 
		processing application.  Hypothetical (and not-so hypothetical)
		uses include:
	</p>
	
	<ul>
		<li>A mailing list manager (ie, <a href="http://subetha.tigris.org/">SubEtha</a>)</li>
		<li>A mail server that delivers mail to user inboxes</li>
		<li>A mail archiver like <a href="http://www.mail-archive.com/">Mail Archive</a></li>
		<li>An email test harness like <a href="http://quintanasoft.com/dumbster/">Dumbster</a></li>
	</ul>
	
	
	<h2>A Little History</h2>
	
	<p>
		SubEthaSMTP was split out of the
		<a href="http://subetha.tigris.org/">SubEtha Mail</a> mailing
		list manager because it is a useful standalone component.  When
		we wrote SubEtha, the last thing we wanted to do was write our
		own SMTP server.  In our search for a modular Java SMTP component,
		we examined:
	</p>
	
	<ul>
		<li><a href="http://james.apache.org/">Apache JAMES</a></li>
		<li><a href="http://labs.jboss.com/portal/jbossmail/index.html">JBoss Mail Server</a></li>
		<li><a href="http://quintanasoft.com/dumbster/">Dumbster</a></li>
		<li><a href="http://www.jsmtpd.org/site/">Jsmtpd</a></li>
		<li><a href="http://www.ericdaugherty.com/java/mailserver/">JES</a></li>
		<li><a href="http://jmailsrv.sourceforge.net/">Java Mail Server</a></li>
	</ul>
	
	<p>
		Since you're reading this page you probably already know what we found:
		Six different SMTP implementations without the slightest thought
		given to reusability. Even Jstmpd, which purports to be a "A Modular
		Java SMTP Daemon", isn't.  Furthermore, even though JBoss Mail is in
		active development, the team was unintersted in componentization.
	</p>
	
	<p>
		We hate reinventing wheels.  This should be the LAST $#@%*! JAVA
		SMTP IMPLEMENTATION.
	</p>
	
	<h2>How To Use It</h2>
	
	<p>
		Using SubEthaSMTP is trivial:
	</p>
	
<pre>List&lt;MessageListener&gt; listeners = new ArrayList&lt;MessageListener&gt;();
listeners.add(myListener);
SMTPServer smtpServer = new SMTPServer(hostName, bindAddress, port, listeners);
smtpServer.start();</pre>
	
	<p>
		The MessageListener is easy to implement:
	</p>
	
<pre>public interface MessageListener
{
	/**
	 * Called once for every RCPT TO during a SMTP exchange.
	 */
	public boolean accept(String from, String recipient);

	/**
	 * When a message arrives, this method will be called for every recipient
	 * this listener accepted.
	 */
	public void deliver(String from, String recipient, InputStream data) throws TooMuchDataException, IOException;
}</pre>
	
	<p>
		Your listener simply accept()s any recipients it cares about, and
		the SMTP server will deliver() an input stream of the message data.
		Any recipients which are not accepted by a listener will be rejected.
	</p>
	
	<h2>Performance</h2>
	
	<p>
		SubEthaSMTP is multithreaded.  One thread waits for socket accepts
		and then spawns a new handler thread for each connection.
	</p>
	
	<p>
		SubEthaSMTP handles streams efficiently.
	</p>
	<ul>
		<li>
			If only one listener accept()s a message, the network
			InputStream (filtered to remove SMTP protocol bits) is
			handed to the listener.
		</li>
		<li>
			If more than one listener accept()s a message, the
			message data is first buffered.  The buffer will be
			kept in RAM until the data reaches a certain size,
			then the buffer is moved to a temporary disk file.
			Each listener will be delivered a complete copy of
			the buffered message.
		</li>
	</ul>
</body>
</html>
